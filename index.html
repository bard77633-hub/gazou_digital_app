<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>画像のデジタル化体験</title>
  <style>
    :root{--gap:12px;--card-bg:#f8f9fb;--accent:#2b6cb0}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP";margin:16px;background:#fff;color:#111}
    h1{font-size:20px;margin:0 0 8px}
    .layout{display:grid;grid-template-columns:1fr 1fr;gap:var(--gap);align-items:start}
    .card{background:var(--card-bg);padding:12px;border-radius:8px;box-shadow:0 1px 3px rgba(0,0,0,.06)}
    .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    input[type=range]{width:220px}
    canvas{background:#222;border-radius:4px;display:block;max-width:100%}
    .controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .small{font-size:13px;color:#333}
    .muted{font-size:12px;color:#555}
    .bottom{margin-top:12px;display:flex;gap:12px;align-items:flex-start}
    .hist{width:100%;height:120px;background:#fff;border-radius:6px;padding:6px;box-sizing:border-box;border:1px solid #e6eef8}
    .info{font-size:13px}
    .samples button{padding:6px 8px;border-radius:6px;border:1px solid #d0d7e6;background:#fff;cursor:pointer}
    .btn{background:var(--accent);color:#fff;padding:8px 10px;border-radius:6px;border:none;cursor:pointer}
    .muted-box{padding:8px;border-radius:6px;background:#fff;border:1px solid #e6eef8}
    .flex{display:flex;gap:8px;align-items:center}
    .marker{position:absolute;width:10px;height:10px;margin-left:-5px;margin-top:-5px;border-radius:50%;border:2px solid #fff;box-shadow:0 0 4px rgba(0,0,0,.4)}
    @media(max-width:900px){.layout{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <h1>画像のデジタル化を体験しよう！</h1>
  <div class="toolbar card">
    <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;">
      <label class="small">画像選択：<input id="file" type="file" accept="image/*"></label>
      <div class="samples">
        <button id="sample1">風景</button>
        <button id="sample2">人物</button>
        <button id="sample3">イラスト</button>
      </div>
      <button id="reset" class="btn">リセット</button>
      <button id="download" class="btn">結果をダウンロード</button>
    </div>
    <div class="muted" style="margin-top:8px">※ クリックで処理後の画像のその点のRGB (処理前/後) を表示します。ヒストグラムは "Before/After" を切替可能。</div>
  </div>

  <div class="layout" style="margin-top:12px">
    <div class="card">
      <div class="small">元画像 (Original)</div>
      <div style="position:relative;">
        <canvas id="canvasOrig" width="480" height="360"></canvas>
      </div>
    </div>

    <div class="card">
      <div class="small">処理後画像 (Processed)</div>
      <div style="position:relative;">
        <canvas id="canvasProc" width="480" height="360"></canvas>
        <div id="marker" class="marker" style="display:none;background:transparent;border-color:#ff0"></div>
      </div>
    </div>
  </div>

  <div class="layout" style="margin-top:12px">
    <div class="card">
      <div class="controls">
        <div class="flex">
          <label class="small">標本化 (Pixelation): </label>
          <input id="pixRange" type="range" min="1" max="50" value="1">
          <div class="muted" id="pixVal">1</div>
        </div>
        <div class="flex">
          <label class="small">量子化 (Colors): </label>
          <input id="quantRange" type="range" min="2" max="256" value="256">
          <div class="muted" id="quantVal">256</div>
        </div>
        <div class="flex">
          <label class="small">表示サイズ (px): </label>
          <select id="displaySize">
            <option value="480">480</option>
            <option value="360">360</option>
            <option value="240">240</option>
          </select>
        </div>
      </div>

      <div class="bottom">
        <div style="flex:1">
          <div class="muted-box info">
          <div>標本化レベル: <span id="infoPix">1</span> （≈ <span id="infoDPI">72</span> dpi）</div>
          <div>量子化段階: <span id="infoQuant">256</span> （≈ <span id="infoBits">8</span> bit）</div>
          <div>画像サイズ: <span id="infoSize">-</span></div>
          </div>
        </div>
        <div style="width:48%">
          <div style="display:flex;gap:6px;align-items:center;margin-bottom:6px">
            <button id="histToggle" class="btn" style="padding:6px 8px">Before</button>
            <button id="explain" style="padding:6px 8px">説明表示</button>
          </div>
          <canvas id="histCanvas" class="hist" width="600" height="120"></canvas>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="small">選択点のRGB (クリックした点)</div>
      <div class="muted-box" style="min-height:120px">
        <div id="coords">(x= -, y= -)</div>
        <div style="display:flex;gap:12px;margin-top:8px;align-items:center">
          <div>
            <div class="small">処理前</div>
            <div id="rgbBefore" class="info">R=- G=- B=-</div>
          </div>
          <div>
            <div class="small">処理後</div>
            <div id="rgbAfter" class="info">R=- G=- B=-</div>
          </div>
        </div>
        <div style="margin-top:8px">
          <button id="toggleMarker" class="btn" style="padding:6px 8px">マーカー表示/非表示</button>
        </div>
      </div>
    </div>
  </div>

  <div style="margin-top:12px" class="card muted-box">
    <strong>操作メモ：</strong>
    <ol>
      <li>左上で画像を読み込むかサンプルを選ぶ。</li>
      <li>スライダーで標本化（モザイク）と量子化（色の段階）を調整。</li>
      <li>処理後画像をクリックすると、その点の値とヒストグラムが見られます。</li>
    </ol>
  </div>

  <script>
    // --- DOM ---
    const fileInput = document.getElementById('file');
    const canvasOrig = document.getElementById('canvasOrig');
    const canvasProc = document.getElementById('canvasProc');
    const ctxOrig = canvasOrig.getContext('2d');
    const ctxProc = canvasProc.getContext('2d');
    const pixRange = document.getElementById('pixRange');
    const quantRange = document.getElementById('quantRange');
    const pixVal = document.getElementById('pixVal');
    const quantVal = document.getElementById('quantVal');
    const infoPix = document.getElementById('infoPix');
    const infoQuant = document.getElementById('infoQuant');
    const infoBits = document.getElementById('infoBits');
    const infoDPI = document.getElementById('infoDPI');
    const infoSize = document.getElementById('infoSize');
    const displaySize = document.getElementById('displaySize');
    const histCanvas = document.getElementById('histCanvas');
    const histCtx = histCanvas.getContext('2d');
    const histToggle = document.getElementById('histToggle');
    const coords = document.getElementById('coords');
    const rgbBefore = document.getElementById('rgbBefore');
    const rgbAfter = document.getElementById('rgbAfter');
    const marker = document.getElementById('marker');
    const toggleMarkerBtn = document.getElementById('toggleMarker');
    const resetBtn = document.getElementById('reset');
    const sample1 = document.getElementById('sample1');
    const sample2 = document.getElementById('sample2');
    const sample3 = document.getElementById('sample3');
    const downloadBtn = document.getElementById('download');
    const explainBtn = document.getElementById('explain');

    // --- state ---
    let image = new Image();
    let origImageData = null;
    let procImageData = null;
    let currentHistMode = 'before'; // before | after
    let showMarker = true;
    let displayW = 480, displayH = 360;

    // default sample SVG images (data urls) - simple illustrations
    const sampleSVG1 = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" width="800" height="600">
        <rect width="100%" height="100%" fill="#87ceeb"/>
        <circle cx="600" cy="120" r="60" fill="#fff59d"/>
        <rect x="0" y="420" width="800" height="180" fill="#2e8b57"/>
        <g fill="#fff"><text x="40" y="80" font-size="36">風景サンプル</text></g>
      </svg>`);

    const sampleSVG2 = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" width="800" height="600">
        <rect width="100%" height="100%" fill="#f4f4f8"/>
        <g transform="translate(120,60)">
          <circle cx="120" cy="120" r="100" fill="#f8c3c3"/>
          <rect x="60" y="240" width="120" height="200" fill="#8fb3ff"/>
        </g>
        <text x="40" y="40" font-size="32">人物サンプル</text>
      </svg>`);

    const sampleSVG3 = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" width="800" height="600">
        <rect width="100%" height="100%" fill="#fff4e6"/>
        <g>
          <rect x="40" y="40" width="220" height="220" fill="#ff6b6b"/>
          <circle cx="420" cy="150" r="110" fill="#ffd43b"/>
          <polygon points="620,40 720,200 520,200" fill="#6be6b5"/>
        </g>
        <text x="40" y="320" font-size="28">イラストサンプル</text>
      </svg>`);

    // --- helpers ---
    function setDisplaySize(s){
      displayW = +s; displayH = Math.round(s * 3/4);
      canvasOrig.width = canvasProc.width = displayW;
      canvasOrig.height = canvasProc.height = displayH;
      infoSize.textContent = `${displayW} x ${displayH}`;
      redrawAll();
    }

    function loadImageFromSrc(src){
      const img = new Image();
      img.onload = () => {
        image = img;
        // fit to display size while preserving aspect ratio
        const ratio = img.width / img.height;
        const w = displayW; const h = Math.round(w / ratio);
        canvasOrig.width = canvasProc.width = w;
        canvasOrig.height = canvasProc.height = h;
        ctxOrig.clearRect(0,0,canvasOrig.width,canvasOrig.height);
        ctxOrig.drawImage(img, 0, 0, canvasOrig.width, canvasOrig.height);
        origImageData = ctxOrig.getImageData(0,0,canvasOrig.width, canvasOrig.height);
        infoSize.textContent = `${canvasOrig.width} x ${canvasOrig.height}`;
        redrawAll();
      };
      img.src = src;
    }

    function quantizeValue(v, levels){
      const step = 256 / levels;
      return Math.floor(v / step) * step + Math.floor(step/2);
    }

    function processImage(){
      if(!origImageData) return;
      const pixLevel = +pixRange.value; // 1..50 (1=original)
      const qLevels = +quantRange.value; // 2..256
      infoDPI.textContent = Math.round(72 * 1/ pixLevel);

      // pixelation using an offscreen canvas scaled down
      const off = document.createElement('canvas');
      const ow = Math.max(1, Math.floor(canvasOrig.width / pixLevel));
      const oh = Math.max(1, Math.floor(canvasOrig.height / pixLevel));
      off.width = ow; off.height = oh;
      const offCtx = off.getContext('2d');
      // draw original into offscreen tiny canvas
      offCtx.drawImage(canvasOrig, 0, 0, ow, oh);
      // enlarge back to processed canvas with image smoothing disabled -> blocky
      ctxProc.imageSmoothingEnabled = false;
      ctxProc.clearRect(0,0,canvasProc.width, canvasProc.height);
      ctxProc.drawImage(off, 0, 0, canvasProc.width, canvasProc.height);

      // apply quantization
      let img = ctxProc.getImageData(0,0,canvasProc.width, canvasProc.height);
      const d = img.data;
      for(let i=0;i<d.length;i+=4){
        d[i] = quantizeValue(d[i], qLevels);
        d[i+1] = quantizeValue(d[i+1], qLevels);
        d[i+2] = quantizeValue(d[i+2], qLevels);
      }
      ctxProc.putImageData(img, 0, 0);
      procImageData = img;
    }

    function redrawAll(){
      // redraw orig canvas from image if exists
      if(image && image.complete){
        ctxOrig.clearRect(0,0,canvasOrig.width, canvasOrig.height);
        ctxOrig.drawImage(image, 0, 0, canvasOrig.width, canvasOrig.height);
        origImageData = ctxOrig.getImageData(0,0,canvasOrig.width, canvasOrig.height);
      }
      processImage();
      drawHistogram();
    }

    function drawHistogram(){
      const mode = currentHistMode; // before | after
      const w = histCanvas.width; const h = histCanvas.height;
      histCtx.clearRect(0,0,w,h);
      if(!origImageData) return;
      // choose source image data
      const src = (mode==='before') ? origImageData : procImageData;
      if(!src) return;
      const countsR = new Uint32Array(256);
      const countsG = new Uint32Array(256);
      const countsB = new Uint32Array(256);
      for(let i=0;i<src.data.length;i+=4){
        countsR[src.data[i]]++;
        countsG[src.data[i+1]]++;
        countsB[src.data[i+2]]++;
      }
      // normalize
      const maxCount = Math.max(...countsR, ...countsG, ...countsB);
      // draw simple bars
      const bw = Math.max(1, Math.floor(w/256));
      for(let i=0;i<256;i++){
        const x = i * bw;
        // R
        histCtx.fillStyle = 'rgba(200,40,40,0.8)';
        const rh = (countsR[i]/maxCount) * h;
        histCtx.fillRect(x, h-rh, bw, rh);
        // G (draw slightly thinner)
        histCtx.fillStyle = 'rgba(40,150,40,0.7)';
        const gh = (countsG[i]/maxCount) * h;
        histCtx.fillRect(x, h-gh, Math.max(1,bw-1), gh);
        // B
        histCtx.fillStyle = 'rgba(50,80,200,0.7)';
        const bh = (countsB[i]/maxCount) * h;
        histCtx.fillRect(x, h-bh, Math.max(1,bw-2), bh);
      }
    }

    // --- events ---
    pixRange.addEventListener('input', ()=>{
      pixVal.textContent = pixRange.value;
      infoPix.textContent = pixRange.value;
      infoDPI.textContent = Math.round(72/pixRange.value);
      redrawAll();
    });

    quantRange.addEventListener('input', ()=>{
      quantVal.textContent = quantRange.value;
      infoQuant.textContent = quantRange.value;
      const bits = Math.log2(+quantRange.value).toFixed(2);
      infoBits.textContent = isFinite(bits)?bits:'-';
      redrawAll();
    });

    displaySize.addEventListener('change', ()=>{
      setDisplaySize(displaySize.value);
    });

    histToggle.addEventListener('click', ()=>{
      currentHistMode = (currentHistMode==='before')? 'after' : 'before';
      histToggle.textContent = (currentHistMode==='before')? 'Before' : 'After';
      drawHistogram();
    });

    canvasProc.addEventListener('click', (ev)=>{
      if(!origImageData || !procImageData) return;
      const rect = canvasProc.getBoundingClientRect();
      const x = Math.floor((ev.clientX - rect.left) * (canvasProc.width/rect.width));
      const y = Math.floor((ev.clientY - rect.top) * (canvasProc.height/rect.height));
      coords.textContent = `(x=${x}, y=${y})`;
      const idx = (y*procImageData.width + x) * 4;
      const rA = procImageData.data[idx];
      const gA = procImageData.data[idx+1];
      const bA = procImageData.data[idx+2];
      rgbAfter.textContent = `R=${rA} G=${gA} B=${bA}`;
      // original
      const oidx = (y*origImageData.width + x) * 4;
      const rB = origImageData.data[oidx];
      const gB = origImageData.data[oidx+1];
      const bB = origImageData.data[oidx+2];
      rgbBefore.textContent = `R=${rB} G=${gB} B=${bB}`;

      if(showMarker){
        marker.style.display = 'block';
        // position marker relative to processed canvas
        const mRect = canvasProc.getBoundingClientRect();
        const left = rect.left + (x/ canvasProc.width) * rect.width;
        const top = rect.top + (y/ canvasProc.height) * rect.height;
        // use absolute position
        marker.style.position = 'fixed';
        marker.style.left = `${left}px`;
        marker.style.top = `${top}px`;
        marker.style.width = '14px';
        marker.style.height = '14px';
        marker.style.borderRadius = '50%';
        marker.style.border = '2px solid #fff';
        marker.style.background = `rgb(${rA},${gA},${bA})`;
      }

      // when user clicks, also show histogram for after by default
      currentHistMode = 'after';
      histToggle.textContent = 'After';
      drawHistogram();
    });

    toggleMarkerBtn.addEventListener('click', ()=>{
      showMarker = !showMarker;
      marker.style.display = showMarker? 'block' : 'none';
    });

    resetBtn.addEventListener('click', ()=>{
      pixRange.value = 1; quantRange.value = 256; pixVal.textContent='1'; quantVal.textContent='256'; infoPix.textContent='1'; infoQuant.textContent='256'; infoBits.textContent='8'; redrawAll();
    });

    // file load
    fileInput.addEventListener('change', (e)=>{
      const f = e.target.files?.[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      loadImageFromSrc(url);
    });

    sample1.addEventListener('click', ()=> loadImageFromSrc(sampleSVG1));
    sample2.addEventListener('click', ()=> loadImageFromSrc(sampleSVG2));
    sample3.addEventListener('click', ()=> loadImageFromSrc(sampleSVG3));

    downloadBtn.addEventListener('click', ()=>{
      const link = document.createElement('a');
      link.href = canvasProc.toDataURL('image/png');
      link.download = 'processed.png';
      link.click();
    });

    explainBtn.addEventListener('click', ()=>{
      alert('標本化 (Pixelation): 画素を間引き、拡大してブロック状にする処理です。\n量子化 (Colors): 各色成分を指定した段階に丸めて色数を減らす処理です。');
    });

    // initial load
    (function(){
      setDisplaySize(displaySize.value);
      // load default sample
      loadImageFromSrc(sampleSVG1);
    })();

    // keep hist updated if procImageData changes occasionally
    const raf = ()=>{ drawHistogram(); requestAnimationFrame(raf); };
    // start but don't spam: run every second-ish via setInterval for responsiveness
    setInterval(()=>{ drawHistogram(); }, 800);
  </script>
</body>
</html>
