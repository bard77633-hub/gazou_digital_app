<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>画像のデジタル化体験</title>
<style>
:root{--gap:12px;--card-bg:#f8f9fb;--accent:#2b6cb0}
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP";margin:16px;background:#fff;color:#111}
h1{font-size:20px;margin:0 0 8px}
.layout{display:grid;grid-template-columns:1fr 1fr;gap:var(--gap);align-items:start}
.card{background:var(--card-bg);padding:12px;border-radius:8px;box-shadow:0 1px 3px rgba(0,0,0,.06)}
.toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
input[type=range]{width:220px}
canvas{background:#222;border-radius:4px;display:block;max-width:100%}
.controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
.small{font-size:13px;color:#333}
.muted{font-size:12px;color:#555}
.bottom{margin-top:12px;display:flex;gap:12px;align-items:flex-start}
.hist{width:100%;height:120px;background:#fff;border-radius:6px;padding:6px;box-sizing:border-box;border:1px solid #e6eef8}
.info{font-size:13px}
.samples button{padding:6px 8px;border-radius:6px;border:1px solid #d0d7e6;background:#fff;cursor:pointer}
.btn{background:var(--accent);color:#fff;padding:8px 10px;border-radius:6px;border:none;cursor:pointer}
.muted-box{padding:8px;border-radius:6px;background:#fff;border:1px solid #e6eef8}
.flex{display:flex;gap:8px;align-items:center}
.marker{position:absolute;width:10px;height:10px;margin-left:-5px;margin-top:-5px;border-radius:50%;border:2px solid #fff;box-shadow:0 0 4px rgba(0,0,0,.4)}
@media(max-width:900px){.layout{grid-template-columns:1fr}}
</style>
</head>
<body>
<h1>画像のデジタル化を体験しよう！</h1>

<!-- ツールバー -->
<div class="toolbar card">
  <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;">
    <label class="small">画像選択：<input id="file" type="file" accept="image/*"></label>
    <div class="samples">
      <button id="sample1">風景</button>
      <button id="sample2">人物</button>
      <button id="sample3">イラスト</button>
    </div>
    <button id="reset" class="btn">リセット</button>
    <button id="download" class="btn">結果をダウンロード</button>
  </div>
  <div class="muted" style="margin-top:8px">※ クリックで処理後の画像のその点のRGB (処理前/後) を表示。ヒストグラムはBefore/After切替可能。</div>
</div>

<!-- 左右キャンバス表示 -->
<div class="layout" style="margin-top:12px">
  <div class="card">
    <div class="small">元画像 (Original)</div>
    <div style="position:relative;">
      <canvas id="canvasOrig" width="480" height="360"></canvas>
    </div>
  </div>

  <div class="card">
    <div class="small">処理後画像 (Processed)</div>
    <div style="position:relative;">
      <canvas id="canvasProc" width="480" height="360"></canvas>
      <div id="marker" class="marker" style="display:none;background:transparent;border-color:#ff0"></div>
    </div>
  </div>
</div>

<!-- コントロールと情報 -->
<div class="layout" style="margin-top:12px">
  <div class="card">
    <div class="controls">
      <div class="flex">
        <label class="small">標本化 (Pixelation): </label>
        <input id="pixRange" type="range" min="1" max="50" value="1">
        <div class="muted" id="pixVal">1</div>
      </div>
      <div class="flex">
        <label class="small">量子化 (Colors): </label>
        <input id="quantRange" type="range" min="2" max="256" value="256">
        <div class="muted" id="quantVal">256</div>
      </div>
      <div class="flex">
        <label class="small">表示サイズ (px): </label>
        <select id="displaySize">
          <option value="480">480</option>
          <option value="360">360</option>
          <option value="240">240</option>
        </select>
      </div>
    </div>

    <div class="bottom">
      <div style="flex:1">
        <div class="muted-box info">
          <div>標本化レベル: <span id="infoPix">1</span> （≈ <span id="infoDPI">72</span> dpi）</div>
          <div>量子化段階: <span id="infoQuant">256</span> （≈ <span id="infoBits">8</span> bit）</div>
          <div>画像サイズ: <span id="infoSize">-</span></div>
        </div>
      </div>
      <div style="width:48%">
        <div style="display:flex;gap:6px;align-items:center;margin-bottom:6px">
          <button id="histToggle" class="btn" style="padding:6px 8px">Before</button>
          <button id="explain" class="btn" style="padding:6px 8px">説明表示</button>
        </div>
        <canvas id="histCanvas" class="hist" width="600" height="120"></canvas>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="small">選択点のRGB (クリックした点)</div>
    <div class="muted-box" style="min-height:120px">
      <div id="coords">(x= -, y= -)</div>
      <div style="display:flex;gap:12px;margin-top:8px;align-items:center">
        <div>
          <div class="small">処理前</div>
          <div id="rgbBefore" class="info">R=- G=- B=-</div>
        </div>
        <div>
          <div class="small">処理後</div>
          <div id="rgbAfter" class="info">R=- G=- B=-</div>
        </div>
      </div>
      <div style="margin-top:8px">
        <button id="toggleMarker" class="btn" style="padding:6px 8px">マーカー表示/非表示</button>
      </div>
    </div>
  </div>
</div>

<div style="margin-top:12px" class="card muted-box" id="explainBox" hidden>
  <strong>説明：</strong>
  <p>このアプリでは、画像を標本化（ピクセル化）し、色を量子化してデジタル画像処理を体験できます。標本化レベルを上げるとモザイク状になり、量子化段階を下げると色数が減ります。クリックした点のRGB値も確認できます。</p>
</div>

<script>
const fileInput = document.getElementById('file');
const canvasOrig = document.getElementById('canvasOrig');
const canvasProc = document.getElementById('canvasProc');
const ctxOrig = canvasOrig.getContext('2d');
const ctxProc = canvasProc.getContext('2d');
const pixRange = document.getElementById('pixRange');
const quantRange = document.getElementById('quantRange');
const pixVal = document.getElementById('pixVal');
const quantVal = document.getElementById('quantVal');
const infoPix = document.getElementById('infoPix');
const infoQuant = document.getElementById('infoQuant');
const infoBits = document.getElementById('infoBits');
const infoDPI = document.getElementById('infoDPI');
const infoSize = document.getElementById('infoSize');
const displaySize = document.getElementById('displaySize');
const histCanvas = document.getElementById('histCanvas');
const histCtx = histCanvas.getContext('2d');
const histToggle = document.getElementById('histToggle');
const coords = document.getElementById('coords');
const rgbBefore = document.getElementById('rgbBefore');
const rgbAfter = document.getElementById('rgbAfter');
const marker = document.getElementById('marker');
const toggleMarkerBtn = document.getElementById('toggleMarker');
const resetBtn = document.getElementById('reset');
const sample1 = document.getElementById('sample1');
const sample2 = document.getElementById('sample2');
const sample3 = document.getElementById('sample3');
const downloadBtn = document.getElementById('download');
const explainBtn = document.getElementById('explain');
const explainBox = document.getElementById('explainBox');

let image = new Image();
let origImageData = null;
let procImageData = null;
let currentHistMode = 'before';
let showMarker = true;
let displayW = 480, displayH = 360;

// サンプル画像
const sampleSVG1 = 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="800" height="600"><rect width="100%" height="100%" fill="#87ceeb"/><circle cx="600" cy="120" r="60" fill="#fff59d"/><rect x="0" y="420" width="800" height="180" fill="#2e8b57"/><g fill="#fff"><text x="40" y="80" font-size="36">風景サンプル</text></g></svg>`);
const sampleSVG2 = 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="800" height="600"><rect width="100%" height="100%" fill="#f4f4f8"/><g transform="translate(120,60)"><circle cx="120" cy="120" r="100" fill="#f8c3c3"/><rect x="60" y="240" width="120" height="200" fill="#8fb3ff"/></g><text x="40" y="40" font-size="32">人物サンプル</text></svg>`);
const sampleSVG3 = 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="800" height="600"><rect width="100%" height="100%" fill="#fff4e6"/><g><rect x="40" y="40" width="220" height="220" fill="#ff6b6b"/><circle cx="420" cy="150" r="110" fill="#ffd43b"/><polygon points="620,40 720,200 520,200" fill="#6be6b5"/></g><text x="40" y="320" font-size="28">イラストサンプル</text></svg>`);

function setDisplaySize(s){
  displayW = +s; displayH = Math.round(s*3/4);
  canvasOrig.width = canvasProc.width = displayW;
  canvasOrig.height = canvasProc.height = displayH;
  infoSize.textContent = `${displayW} x ${displayH}`;
  redrawAll();
}

function loadImageFromSrc(src){
  const img = new Image();
  img.onload = ()=>{
    image = img;
    const ratio = img.width / img.height;
    const w = displayW; const h = Math.round(w/ratio);
    canvasOrig.width = canvasProc.width = w;
    canvasOrig.height = canvasProc.height = h;
    ctxOrig.clearRect(0,0,w,h);
    ctxOrig.drawImage(img,0,0,w,h);
    origImageData = ctxOrig.getImageData(0,0,w,h);
    infoSize.textContent = `${w} x ${h}`;
    redrawAll();
  };
  img.src = src;
}

function quantizeValue(v, levels){
  const step = 256/levels;
  return Math.floor(v/step)*step + Math.floor(step/2);
}

function processImage(){
  if(!origImageData) return;
  const pixLevel = +pixRange.value;
  const qLevels = +quantRange.value;
  infoDPI.textContent = Math.round(72 / pixLevel);

  const off = document.createElement('canvas');
  const ow = Math.max(1, Math.floor(canvasOrig.width/pixLevel));
  const oh = Math.max(1, Math.floor(canvasOrig.height/pixLevel));
  off.width = ow; off.height = oh;
  const offCtx = off.getContext('2d');
  offCtx.drawImage(canvasOrig,0,0,ow,oh);
  ctxProc.imageSmoothingEnabled = false;
  ctxProc.clearRect(0,0,canvasProc.width,canvasProc.height);
  ctxProc.drawImage(off,0,0,canvasProc.width,canvasProc.height);

  let img = ctxProc.getImageData(0,0,canvasProc.width,canvasProc.height);
  const d = img.data;
  for(let i=0;i<d.length;i+=4){
    d[i]=quantizeValue(d[i],qLevels);
    d[i+1]=quantizeValue(d[i+1],qLevels);
    d[i+2]=quantizeValue(d[i+2],qLevels);
  }
  ctxProc.putImageData(img,0,0);
  procImageData = img;
}

function redrawAll(){
  if(image && image.complete){
    ctxOrig.clearRect(0,0,canvasOrig.width,canvasOrig.height);
    ctxOrig.drawImage(image,0,0,canvasOrig.width,canvasOrig.height);
    origImageData = ctxOrig.getImageData(0,0,canvasOrig.width,canvasOrig.height);
  }
  processImage();
  drawHistogram();
}

function drawHistogram(){
  const mode = currentHistMode;
  const w = histCanvas.width; const h = histCanvas.height;
  histCtx.clearRect(0,0,w,h);
  if(!origImageData) return;
  const src = (mode==='before') ? origImageData : procImageData;
  if(!src) return;
  const countsR = new Uint32Array(256), countsG = new Uint32Array(256), countsB = new Uint32Array(256);
  for(let i=0;i<src.data.length;i+=4){
    countsR[src.data[i]]++; countsG[src.data[i+1]]++; countsB[src.data[i+2]]++;
  }
  const maxCount = Math.max(...countsR,...countsG,...countsB);
  const bw = Math.max(1,Math.floor(w/256));
  for(let i=0;i<256;i++){
    histCtx.fillStyle='rgba(200,40,40,0.8)';
    histCtx.fillRect(i*bw,h-(countsR[i]/maxCount*h),bw,(countsR[i]/maxCount*h));
    histCtx.fillStyle='rgba(40,150,40,0.7)';
    histCtx.fillRect(i*bw,h-(countsG[i]/maxCount*h),Math.max(1,bw-1),(countsG[i]/maxCount*h));
    histCtx.fillStyle='rgba(50,80,200,0.7)';
    histCtx.fillRect(i*bw,h-(countsB[i]/maxCount*h),Math.max(1,bw-2),(countsB[i]/maxCount*h));
  }
}

// --- イベント ---
pixRange.addEventListener('input', ()=>{
  pixVal.textContent = pixRange.value;
  infoPix.textContent = pixRange.value;
  infoDPI.textContent = Math.round(72/pixRange.value);
  redrawAll();
});
quantRange.addEventListener('input', ()=>{
  quantVal.textContent = quantRange.value;
  infoQuant.textContent = quantRange.value;
  infoBits.textContent = Math.round(Math.log2(+quantRange.value));
  redrawAll();
});
displaySize.addEventListener('change', ()=>setDisplaySize(displaySize.value));

canvasProc.addEventListener('click',(e)=>{
  if(!procImageData || !origImageData) return;
  const rect = canvasProc.getBoundingClientRect();
  const x = Math.floor((e.clientX-rect.left)*canvasProc.width/rect.width);
  const y = Math.floor((e.clientY-rect.top)*canvasProc.height/rect.height);
  coords.textContent = `(x=${x}, y=${y})`;
  const i = (y*canvasProc.width + x)*4;
  const o = origImageData.data;
  const p = procImageData.data;
  rgbBefore.textContent = `R=${o[i]} G=${o[i+1]} B=${o[i+2]}`;
  rgbAfter.textContent = `R=${p[i]} G=${p[i+1]} B=${p[i+2]}`;
  if(showMarker){
    marker.style.left = `${e.clientX - rect.left}px`;
    marker.style.top = `${e.clientY - rect.top}px`;
    marker.style.display='block';
  }
});

toggleMarkerBtn.addEventListener('click', ()=>{
  showMarker = !showMarker;
  marker.style.display = showMarker ? 'block':'none';
});

histToggle.add
